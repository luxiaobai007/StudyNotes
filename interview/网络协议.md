[toc]



# HTTP协议

HTTP是一种不保存状态，即无状态协议。对于发送过的请求或响应都不做持久化处理。

HTTP/1.1虽然是无状态协议，为了实现期望的保持状态功能，就引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态。

超文本传输协议,是客户端浏览器或其他程序与Web服务器之间的应用层通信协议.

## 请求报文格式

第一部分：请求行（由请求方法、请求路径、请求协议/版本组成）
第二部分：请求头（从第二行至第N行，由键值对组成，Key:Value）
第三部分：空行（由回车换行组成）
第四部分：请求正文（请求消息体）

## 常见请求头含义

1、User-Agent：告诉服务器客户端的相关信息（如果是浏览器会有版本，内核等信息）
2、referer：告诉服务器，此请求是从哪个页面上发出来 (防盗链)
3、 X-Requested-With：告诉服务器这个是一个ajax请求
4、Cookie：带给服务器的cookie信息
5、content-type：告诉服务器消息体的数据类型

## HTTP响应报文

响应报文格式：四个部分组成
第一部分：状态行，独占一行。由协议/协议的版本、状
态码、状态描述符组成
第二部分：响应头，从第二行到第N行。由键值对组
成。
第三部分：空行。独占一行的。由回车换行组成。
第四部分：响应的正文



## 常见响应头含义

1、location：告诉浏览器跳到哪里
2、content-length：告诉浏览器回送数据的长度
3、content-type：告诉浏览器回送数据的类型



## **常见的HTTP相应状态码**

返回的状态
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求

200：请求被正常处理

204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。

301：永久性重定向
302：临时重定向
303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法

400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源
500：服务器内部错误
503：服务器正忙



## 常见HTTP首部字段

### a、通用首部字段（请求报文与响应报文都会使用的首部字段）

Date：创建报文时间
Connection：连接的管理
Cache-Control：缓存的控制
Transfer-Encoding：报文主体的传输编码方式

### b、请求首部字段（请求报文会使用的首部字段）  

Host：请求资源所在服务器
Accept：可处理的媒体类型
Accept-Charset：可接收的字符集
Accept-Encoding：可接受的内容编码
Accept-Language：可接受的自然语言

### c、响应首部字段（响应报文会使用的首部字段）

Accept-Ranges：可接受的字节范围
Location：令客户端重新定向到的URI
Server：HTTP服务器的安装信息

### d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）

Allow：资源可支持的HTTP方法
Content-Type：实体主类的类型
Content-Encoding：实体主体适用的编码方式
Content-Language：实体主体的自然语言
Content-Length：实体主体的的字节数
Content-Range：实体主体的位置范围，一般用于发出部分请求时使用



## HTTP的缺点与HTTPS

a、通信使用明文不加密，内容可能被窃听
b、不验证通信方身份，可能遭到伪装
c、无法验证报文完整性，可能被篡改

HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护



## HTTP优化

利用负载均衡优化和加速HTTP应用

利用HTTP Cache来优化网站









# HTTP和webSocket

#### 轮询

每隔一段时候，就发出一个询问，了解服务器有没有新的信息.轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）

## WebSocket

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输

服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话



### 握手

握手过程

#### 客户端发送数据格式:

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

- Connection：必须设置Upgrade，表示客户端希望连接升级
- Upgrade：必须设置Websocket，表示希望升级到Websocket协议
- Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接
- Sec-WebSocket-Version ：表示支持的Websocket版本



#### 服务端返回的数据格式:

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat
```

- HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接
- Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要

### 特点

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。





### 应用场景

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新





# **浏览器输入网址到页面渲染全过程**

- DNS 解析 ==通过DNS将URL解析成IP地址==
  - 解析过程
    - 向浏览器的缓存中查找;如果没有则进入下一步
    - 向系统缓存(本地的hosts文件)查找;如果没有则进行下一步
    - 向路由器查询DNS缓存;如果没有则进行下一步;
    - 向ISP(运营商)DNS缓存中查找,如果没有进行下一步
    - 向根域名服务器=>顶级域名服务器中查找
- TCP 连接  三次握手
  - 客户机向服务器发送一个建立连接的请求
  - 服务器接到请求后发送同意连接的信号
  - 主机接到同意连接的信号后，再次向服务器发送了确认信号
- 发送 HTTP 请求 
  - **浏览器根据解析到的IP地址和端口号发起HTTP请求**，HTTP请求包括header和body
  - 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件
  - 服务器将得到的 HTML 文件发送给浏览器
- 服务器处理请求并返回 HTTP 报文 
- 浏览器解析渲染页面 **浏览器拿到HTML文件后，根据渲染规则进行渲染**
  - DOM 树：解析 HTML 构建 DOM(DOM 树)
  - CSS 树：解析 CSS 构建 CSSOM(CSS 树)
  - 渲染树：CSSOM 和 DOM 一起生成 Render Tree(渲染树)
  - 布局（layout）：根据Render Tree浏览器就知道网页中有哪些节点，以及各个节点与 CSS 的关系，从而知道每个节点的位置和几何属性`（重排）`
  - 绘制（Paint）：根据计算好的信息绘制整个页面`（重绘）`
- 连接结束 4次挥手
  - 客户端：我没有数据要发送了，打算断开连接
  - 服务器：你的请求我收到了，我这还有数据没有发送完成，你等下
  - 服务器：我的数据发送完毕，可以断开连接了、
  - 客户端：ok，你断开连接吧（客户端独白：我将在2倍的最大报文段生存时间后关闭连接。如果我再次收到服务器的消息，我就知道服务器没有收到我的这句话，我就再发送一遍）。
    





## 为什么要进行三次握手？如果是两次握手

如下面的对话只有前两句，有可能出现的问题是：客户端之前发送了一个连接请求报文，由于网络原因滞留在网络中，后来到达服务器端，服务器接收到该请求，就会建立连接，等待客户端传送数据。而此时客户端压根就不知道发生了什么，白白造成了服务器资源浪费。

- 第一次握手： A给B打电话说，你可以听到我说话吗？
- 第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？  
- 第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！

　　**在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。** **这样，就可以开始正常通信了。**

　如果两次，那么B无法确定B的信息A是否能收到，所以如果B先说话，可能后面的A都收不到，会出现问题 。

　　如果四次，那么就造成了浪费，因为在三次结束之后，就已经可以保证A可以给B发信息，A可以收到B的信息； B可以给A发信息，B可以收到A的信息。


















#### 资源链接

[1]: https://blog.csdn.net/qq_36035589/article/details/114090259

[2]: https://github.com/febobo/web-interview/issues/152
[3]: https://blog.csdn.net/x550392236/article/details/106473683

