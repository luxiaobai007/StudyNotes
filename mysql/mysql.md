# 索引

索引是⼀种数据结构,可以帮助我们快速的进⾏数据的查找

排好序的快速查找数据结构(B tree)



索引的数据结构和具体存储引擎的实现有关, 在MySQL中使⽤较多的索引有Hash索引,B+树索引等,⽽我们经常使⽤的InnoDB存储 引擎的默认索引实现为:B+树索引. 



## 优势

- 建立索引,提高数据检索的效率,降低数据库的IO成本
- 通过索引列堆数据进行排序,降低数据排序成本,降低了CPU的消耗



## 劣势

- 降低了更新表的速度,不仅要保存数据,还有保存索引文件



## 索引分类

### 单值索引

即一个索引只包含单个列,一个表有多个单列索引



### 唯一索引(unique)

索引列的值必须唯一,单允许有空值



### 复合索引

即一个索引保护多个列



### 基本语法

#### 创建

 ```mysql
create [unique] index indexName on mytable(columnname(length));
alter mytable add [unique] index [indexName] on (columnname(length))
 ```



#### 删除

```mysql
drop index [indexName] on mytable;
```



#### 查看

```mysql
show index from table name
```



## BTree索引

### 什么情况下需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段,外键关系建立索引
4. 频繁更新的字段不适合创建索引
5. Where条件里用不到的字段不会创建索引
6. 单键/组合索引的选择问题?(在高并发下倾向创建组合索引)
7. 查询中排序的字段,排序字段若通过索引去访问将大大提高排序速度
8. 查询中统计或者分组字段



### 什么情况下不需要创建索引

1. 表记录太少
2. 经常更删改的表
3. 数据重复且分布平均的表字段



## 性能分析

### Explain

可以模拟优化器执行SQL查询语句,从而知道MYSQL是如何处理SQL语句的.分析查询语句或是表结构的性能瓶颈.

```mysql
explain + sql语句

执行计划包含的信息
+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+
```

-   **Id**:  select查询的序列号,表示查询中执行select子句或操作表的顺序
  - ID相同,执行顺序由上至下
  - id不同,如果是子查询,id的序号会递增**,id值越大优先级越高,越先执行**
  - id相同又不同,ID相同可以认为是一组,从上往下顺序执行;在所有组中,ID值越大,优先级越高,越先执行.
- select_type: 
  - 类型:
    1. SIMPLE:简单的子查询,查询中不包含子查询或者UNION
    2. PRIAMRY: 查询中若包含任何复杂的子部分,最外层查询则被标记为
    3. SUBQUERY: 在SELECT或WHERE列表中包含了子查询
    4. DERIVED:在FROM列表中包含的子查询被标记为DERIVED(衍生),Mysql会递归执行这些子查询,把结果放在临时表
    5. UNION: 若第二个SELECT出现在UNION之后,则被标记为UNION; 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为: DERIVED
    6. UNION RESULT:从UNION表获取结果的SELECT
- **type:**
  - 访问类型排列,显示查询使用了何种类型: 最好到最差==》 
    - system>const>eq_ref>ref>range>index>ALL。一般来说,得保证查询至少达到range级别,最好能达到ref
  - system: 表只有一行记录(等于系统表)这是const类型的特列,平时不会出现,忽略不计
  - const: 通过索引一次就找到,const用于比较primary key或者unique索引.因为只匹配一行数据,所以很快,如将主键置于where列表中,MYSQL就能将该查询转换为一个常量
  - eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配.常见于主键或唯一索引扫描
  - ref:  非唯一性索引扫描,返回匹配某个单独值的所有行.本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体
  - range:  只检索给定范围的行,使用一个索引来选择行.key列显示使用了那个索引.一般就是在你的where语句中出现了between、<、>、in等的查询.这种范围扫描索引扫描比全表扫描要好,因为它只需要开始于索引的某一点,而结束语另一点,不用扫描全部索引.
  - index: Full Index Scan. index与ALL区别为index类型只便利索引树.这通常比ALL快,因为索引文件通常比数据文件小.(也就是说**虽然all和index都是读全表,但index是从索引中读取的,而all是从硬盘中读的**)
  - all: Full Table Scan,将遍历全表以找到匹配的行.
- Possible_keys: 显示可能应用在这张表中的索引,一个或多个. 查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用
- **key**: 实际使用的索引.如果为NULL,则没有使用索引. **查询中若使用了覆盖索引,则该索引仅出现在key列**表中.
- key_len:  表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度.在不损失精确性的情况下,长度越短越好. key_len显示的值为索引字段的最大可能,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的
- ref: 显示索引的那一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值
- **rows**:  根据表统计信息及索引选用信息,大致估算出找到所需的记录所需要读取的行数,越少越好
- **Extra**: 包含不适合在其他列中显示但十分重要的额外信息
  - **Using filesort** : 说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取.mysql中无法利用索引完成的排序操作称为“文件排序” .( **出现这个尽快优化,sql内部自己再一次进行了排序,多了一次索引排序==九死一生**)
  - **Using temporary**(火烧眉毛,尽快解决):  使用了临时表保存中间结果,MySql在对查询结果排序时,使用临时表.常见于排序order by和分组查询group by.
  - **Using index**:  表示相应的select操作中使用了覆盖索引(Covering Index), 避免了访问表的数据行,效率不错. 如果同时出现using where,表明索引被用来执行索引键值的查找; 如果没有同时出现using where, 表明索引用来读取数据而非执行查找动作.
    - **覆盖索引**(Covering Index):  select的数据列只用从索引中就能够取得,不必读取数据行,Mysql可以利用索引返回select列表中的字段,而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖
  - Using where: 表明使用了where过滤
  - Using join buffer: 使用了连续缓存
  - impossible where: where子句的值总是false,不能用来获取任何元组
  - select tables optimized away: 在没有 group by子句的情况下,基于索引优化MIN/MAX操作或者对于M YISAM存储引擎优化COUNT(*)操作,不必等到执行阶段在进行运算. 查询执行计划生成的阶段即完成优化
  - distinct: 优化distinct操作,在找到第一匹配的元组后即停止找同样值的动作



# 索引优化

## 索引分析

### 单表









### 两表



### 三表





## 索引失效(应该避免)



## 一般性建议