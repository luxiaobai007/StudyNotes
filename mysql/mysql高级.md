[toc]



# 索引

索引是⼀种数据结构,可以帮助我们快速的进⾏数据的查找

排好序的快速查找数据结构(B tree)



索引的数据结构和具体存储引擎的实现有关, 在MySQL中使⽤较多的索引有Hash索引,B+树索引等,⽽我们经常使⽤的InnoDB存储 引擎的默认索引实现为:B+树索引. 



## 优势

- 建立索引,提高数据检索的效率,降低数据库的IO成本
- 通过索引列堆数据进行排序,降低数据排序成本,降低了CPU的消耗



## 劣势

- 降低了更新表的速度,不仅要保存数据,还有保存索引文件



## 索引分类

### 单值索引

即一个索引只包含单个列,一个表有多个单列索引



### 唯一索引(unique)

索引列的值必须唯一,单允许有空值



### 复合索引

即一个索引保护多个列



### 基本语法

#### 创建

 ```mysql
create [unique] index indexName on mytable(columnname(length));
alter mytable add [unique] index [indexName] on (columnname(length))
 ```



#### 删除

```mysql
drop index [indexName] on mytable;
```



#### 查看

```mysql
show index from table name
```



## BTree索引

### 什么情况下需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段,外键关系建立索引
4. 频繁更新的字段不适合创建索引
5. Where条件里用不到的字段不会创建索引
6. 单键/组合索引的选择问题?(在高并发下倾向创建组合索引)
7. 查询中排序的字段,排序字段若通过索引去访问将大大提高排序速度
8. 查询中统计或者分组字段



### 什么情况下不需要创建索引

1. 表记录太少
2. 经常更删改的表
3. 数据重复且分布平均的表字段



## 性能分析

### Explain

可以模拟优化器执行SQL查询语句,从而知道MYSQL是如何处理SQL语句的.分析查询语句或是表结构的性能瓶颈.

```mysql
explain + sql语句

执行计划包含的信息
+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+
```

-   **Id**:  select查询的序列号,表示查询中执行select子句或操作表的顺序
  - ID相同,执行顺序由上至下
  - id不同,如果是子查询,id的序号会递增**,id值越大优先级越高,越先执行**
  - id相同又不同,ID相同可以认为是一组,从上往下顺序执行;在所有组中,ID值越大,优先级越高,越先执行.
- select_type: 
  - 类型:
    1. SIMPLE:简单的子查询,查询中不包含子查询或者UNION
    2. PRIAMRY: 查询中若包含任何复杂的子部分,最外层查询则被标记为
    3. SUBQUERY: 在SELECT或WHERE列表中包含了子查询
    4. DERIVED:在FROM列表中包含的子查询被标记为DERIVED(衍生),Mysql会递归执行这些子查询,把结果放在临时表
    5. UNION: 若第二个SELECT出现在UNION之后,则被标记为UNION; 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为: DERIVED
    6. UNION RESULT:从UNION表获取结果的SELECT
- **type:**
  - 访问类型排列,显示查询使用了何种类型: 最好到最差==》 
    - system>const>eq_ref>ref>range>index>ALL。一般来说,得保证查询至少达到range级别,最好能达到ref
  - system: 表只有一行记录(等于系统表)这是const类型的特列,平时不会出现,忽略不计
  - const: 通过索引一次就找到,const用于比较primary key或者unique索引.因为只匹配一行数据,所以很快,如将主键置于where列表中,MYSQL就能将该查询转换为一个常量
  - eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配.常见于主键或唯一索引扫描
  - ref:  非唯一性索引扫描,返回匹配某个单独值的所有行.本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体
  - range:  只检索给定范围的行,使用一个索引来选择行.key列显示使用了那个索引.一般就是在你的where语句中出现了between、<、>、in等的查询.这种范围扫描索引扫描比全表扫描要好,因为它只需要开始于索引的某一点,而结束语另一点,不用扫描全部索引.
  - index: Full Index Scan. index与ALL区别为index类型只便利索引树.这通常比ALL快,因为索引文件通常比数据文件小.(也就是说**虽然all和index都是读全表,但index是从索引中读取的,而all是从硬盘中读的**)
  - all: Full Table Scan,将遍历全表以找到匹配的行.
- Possible_keys: 显示可能应用在这张表中的索引,一个或多个. 查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用
- **key**: 实际使用的索引.如果为NULL,则没有使用索引. **查询中若使用了覆盖索引,则该索引仅出现在key列**表中.
- key_len:  表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度.在不损失精确性的情况下,长度越短越好. key_len显示的值为索引字段的最大可能,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的
- ref: 显示索引的那一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值
- **rows**:  根据表统计信息及索引选用信息,大致估算出找到所需的记录所需要读取的行数,越少越好
- **Extra**: 包含不适合在其他列中显示但十分重要的额外信息
  - **Using filesort** : 说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取.mysql中无法利用索引完成的排序操作称为“文件排序” .( **出现这个尽快优化,sql内部自己再一次进行了排序,多了一次索引排序==九死一生**)
  - **Using temporary**(火烧眉毛,尽快解决):  使用了临时表保存中间结果,MySql在对查询结果排序时,使用临时表.常见于排序order by和分组查询group by.
  - **Using index**:  表示相应的select操作中使用了覆盖索引(Covering Index), 避免了访问表的数据行,效率不错. 如果同时出现using where,表明索引被用来执行索引键值的查找; 如果没有同时出现using where, 表明索引用来读取数据而非执行查找动作.
    - **覆盖索引**(Covering Index):  select的数据列只用从索引中就能够取得,不必读取数据行,Mysql可以利用索引返回select列表中的字段,而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖
  - Using where: 表明使用了where过滤
  - Using join buffer: 使用了连续缓存
  - impossible where: where子句的值总是false,不能用来获取任何元组
  - select tables optimized away: 在没有 group by子句的情况下,基于索引优化MIN/MAX操作或者对于M YISAM存储引擎优化COUNT(*)操作,不必等到执行阶段在进行运算. 查询执行计划生成的阶段即完成优化
  - distinct: 优化distinct操作,在找到第一匹配的元组后即停止找同样值的动作



# 索引优化

## 索引分析

### 单表









### 两表



### 三表





## 索引失效(应该避免)

1. 全值匹配
2. ==最佳左前缀法则== ------如果索引了多列,要遵守最左前缀法则,指的是查询从索引的最左前列开始并且不跳过索引中的列
3. 不在索引列上做任何操作(计算、函数、(自动or手动)类型转换),会导致索引失效而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列
5. 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select *
6. mysql在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描
7. is null, is not null 也无法使用索引
8. like以通配符开头(“%abc..")mysql索引失效会变成全表扫描的操作
9. 字符串不加单引号索引失效
10. 少用or,用他来连接时会索引失效





## 一般性建议

- 对于单键索引,尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候,当前Query中过滤性最好的字段在索引字段顺序中,位置越靠前越好.
- 在选择组合索引的时候,尽量选择可以能够包含当前query中的where字句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的











## B树

一种树状数据结构,能够存储数据、对其进行排序并允许以O(logn)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构

> 概括来说:一个节点可以拥有多于2个子节点的二叉查找树.
>
> B-树为系统最优化大块数据的读和写操作.
>
> B- tree算法减少定位记录时所经历的中间过程,从而加快存取速度.



### 定义

- 根节点至少有两个子节点
- 每个节点有M-1个key,并且以升序排列
- 位于M-1和M key的子节点的值位于M-1和M key对应的value之间
- 其他即诶单至少有M/2个子节点

![B树1](http://qiliu.luxiaobai.cn/img/B%E6%A0%911.png)

​																						**M=4的B树**

B树是2-3树的一种扩展,他允许一个节点有多于2个的元素

演示动画

往B树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 

![B树](http://qiliu.luxiaobai.cn/img/B%E6%A0%91.gif)





## B+树

### B+树和B树的差异

B+树是对B树的一种变形树,它与B树的差异在于:

- 有k个子节点的节点必然有k个关键码
- 非叶节点仅具有索引作用,跟记录有关的信息均存放在叶结点中
- 树的所有叶结点构成一个有序链表,可以按照关键码排序的次序遍历全部记录

![B+树1](http://qiliu.luxiaobai.cn/img/B+%E6%A0%911.png)

​																**M=4的B+树**



### B+树的建立过程

![B+树2](http://qiliu.luxiaobai.cn/img/B+%E6%A0%912.gif)



### B+树和B树的区别

B+树的非叶子节点只包含导航信息,不包含实际的值,所有的叶子节点和相连的节点使用链表相连,便于区间查找和遍历



#### B+ 树的优点

- **IO次数更少**: 由于B+ 树在 内部节点上不包含数据信息,因此内存页中能够存放更多的ke y.数据存放的更加紧密,具有更好的空间局部性.因此访问叶子节点上关联的数据也具有更好的缓存命中率.
- **遍历更加方便**:B+树的叶子节点都是相链的,因此对 整棵树的遍历只需要一次线性遍历叶子结点即可.而且由于数据顺序排列并且相连,所以便于区间查找和搜索.而B树则需要进行每一层的递归遍历.相邻的元素可能子啊内存中不相邻,所以缓存命中型没有B+树好



#### B树的优点

B树的每一个节点都包含key和value,因此经常访问的元素可能离根节点更近,因此访问也更迅速.



![B树和B+树的区别](http://qiliu.luxiaobai.cn/img/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB.webp)





## 为什么Mysql选择B+树做索引

1. **B+树的磁盘读写代价更低**: B+树的内部节点并没有指向关键字具体信息的指针,因此其内部节点相对B树更小,如果把所有同一内部节点的关键字存放在同一盘块中,那么盘块所能容纳的关键字数量也越多,一次性读入内存的需要查找的关键字也就越多,相对IO读写次数就降低了.
2. **B+树的查询效率更加稳定**:由于非终结点并不是最终指向文件内容的节点,而只是叶子节点中关键字的索引.所以任何关键字的查找必须走一条从根节点到叶子节点的路.所有关键字查询的路径长度相同,导致每一个数据的查询效率相当.
3. **B+树更便于遍历**: 由于B+树都存储在叶子节点傻姑娘,分支节点均为索引,方便扫库 ,只需要扫描一遍叶子节点即可,但是B树因为其分支节点同样存储着数据,我们要找到具体的数据,需要进行一次中序遍历来扫描,所以B+树更加适合在区间查询的情况,所以通常B+树用于数据库索引.
4. **B+树更适合基于范围的查询**:B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题,正是为了解决这个问题,B+树应用而生.B+树只需要去遍历叶子节点就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的,而B树不支持这样的操作或者说效率太低.







## **什么是最左前缀原则？什么是最左匹配原则**

最左前缀原则：顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上。

（1）如果第一个字段是范围查询需要单独建一个索引；

（2）在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边；

当创建(a,b,c)复合索引时，想要索引生效的话，只能使用 a和ab、ac和abc三种组合！

实例：以下是常见的几个查询：

```mysql
select 'a','b','c' from A where 'a'='a1';//索引生效
select 'a','b','c' from A where 'b'='b2' And 'c'='c2';//索引失效
SELECT `a`,`b`,`c` FROM A WHERE `a`='a3' AND `c`='c3'; //索引生效，实际上值使用了索引a
```

扩展：想要索引最大化的使用需要至少建几个索引？

答：需要建立复合索引：bc